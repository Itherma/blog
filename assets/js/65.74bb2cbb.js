(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{492:function(t,a,_){"use strict";_.r(a);var r=_(0),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-react组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react组件"}},[t._v("#")]),t._v(" 1. React组件")]),t._v(" "),a("p",[t._v("上一章我们讲了如何将虚拟DOM渲染成真实DOM并挂载，只聊了普通HTML元素的渲染。这一章我们来实现一下组件化相关的功能。组件化是"),a("code",[t._v("React")]),t._v("最核心的功能之一，它可以将UI切分成一些独立的、可复用的组件，这样你就只需专注于构建每一个单独的部件。通过拼装组件来形成页面和应用，就像搭积木一样。那么有没有想过，组件到底产出什么呢？它的种类有哪些呢？")]),t._v(" "),a("p",[t._v("我们可以联想一下平时写组件时的用法，将组件声明在JSX里，然后传入对应的属性，就可以在页面上渲染出对应的组件。通过"),a("code",[t._v("ReactDOM.render(...)")]),t._v("即可渲染组件，在上一章中我们知道"),a("code",[t._v("ReactDOM.render")]),t._v("的作用就是把虚拟DOM渲染成真实DOM，所以我们可以得出，"),a("strong",[t._v("组件的产出一定是虚拟DOM")]),t._v("。")]),t._v(" "),a("p",[t._v("那么组件是如何生成虚拟DOM呢？在React里面组件的分为两种："),a("strong",[t._v("函数组件")]),t._v("和"),a("strong",[t._v("类组件")]),t._v("。下面我们来说一下他们分别是如何声明和挂载的。")]),t._v(" "),a("h2",{attrs:{id:"_2-函数式组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数式组件"}},[t._v("#")]),t._v(" 2. 函数式组件")]),t._v(" "),a("h3",{attrs:{id:"_2-1-函数式组件的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-函数式组件的特点"}},[t._v("#")]),t._v(" 2.1 函数式组件的特点")]),t._v(" "),a("ul",[a("li",[t._v("函数组件接收一个单一的props对象并返回了一个"),a("strong",[t._v("只有一个根节点")]),t._v("的React元素")]),t._v(" "),a("li",[t._v("组件名称必须以大写字母开头，用于区分普通元素还是React组件")]),t._v(" "),a("li",[t._v("组件必须在使用的时候定义或引用它")]),t._v(" "),a("li",[t._v("React元素不但可以是DOM标签，还可以是用户自定义的组件")]),t._v(" "),a("li",[t._v("当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为props")])]),t._v(" "),a("h3",{attrs:{id:"_2-2-函数式组件的渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-函数式组件的渲染过程"}},[t._v("#")]),t._v(" 2.2 函数式组件的渲染过程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://1-1253772569.cos.ap-guangzhou.myqcloud.com/functionComponent.png",alt:"functionComponent"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);