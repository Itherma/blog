(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{672:function(v,_,o){"use strict";o.r(_);var e=o(0),t=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("正则表达式说白了就是一堆"),_("strong",[v._v("约定俗成的匹配规则")]),v._v("。如果从微观入手，你会发现有背不完的规则；如果从宏观入手，你会发现万变不离其宗。所以我们将从宏观到微观依次说起，依次为大家总结"),_("strong",[v._v("三大宏观规则")]),v._v("、"),_("strong",[v._v("两大微观规则")]),v._v("，再附带一部分高级内容。基本可以通过一篇文章让大家"),_("strong",[v._v("理解")]),v._v("正则表达式的主要用法。")]),v._v(" "),_("p",[v._v("先说"),_("strong",[v._v("三大宏观规则")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[_("em",[v._v("我们用大写字母表示抽象的正则规则，主要讨论正则之间的关系，忽略具体的内容")])])]),v._v(" "),_("h2",{attrs:{id:"一、交集规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、交集规则"}},[v._v("#")]),v._v(" 一、交集规则")]),v._v(" "),_("p",[v._v("如果有两个正则表达式"),_("code",[v._v("E")]),v._v("和"),_("code",[v._v("F")]),v._v("，那么"),_("code",[v._v("EF")]),v._v("也是一个正则，表示同时匹配E和F的内容。这跟编程中的"),_("strong",[v._v("逻辑与")]),v._v("是一个意思，跟集合中的"),_("strong",[v._v("交集")]),v._v("也是一个意思。你也可以连接任意多个正则，比如"),_("code",[v._v("EFGH")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"二、并集规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、并集规则"}},[v._v("#")]),v._v(" 二、并集规则")]),v._v(" "),_("p",[v._v("如果有两个正则表达式"),_("code",[v._v("E")]),v._v("和F，那么"),_("code",[v._v("E|F")]),v._v("也是一个正则，表示匹配E或者匹配F。这跟编程中的"),_("strong",[v._v("逻辑或")]),v._v("是一个意思，跟集合中的"),_("strong",[v._v("并集")]),v._v("也是一个意思。 你可以使用|连接任意多个正则表达式，比如"),_("code",[v._v("E|F|G|H")]),v._v("。")]),v._v(" "),_("p",[v._v("如果你要连接非常多的正则，那就得写非常多的竖线，看起来非常乱。所以人们还约定了一种简化记法"),_("code",[v._v("[EFGH]")]),v._v("。也就是你写成"),_("code",[v._v("[EFGH]")]),v._v("跟写成"),_("code",[v._v("E|F|G|H")]),v._v("效果是一样，但前者更简短，更清晰。")]),v._v(" "),_("h2",{attrs:{id:"三、补集规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、补集规则"}},[v._v("#")]),v._v(" 三、补集规则")]),v._v(" "),_("p",[v._v("编程有"),_("strong",[v._v("与或非")]),v._v("，集合有"),_("strong",[v._v("交并补")]),v._v("。正则表达式有没有类似逻辑非或者集合中的补集呢？有，但记法比较复杂。如果你要排除匹配"),_("code",[v._v("E")]),v._v("和"),_("code",[v._v("F")]),v._v("的内容，需要写成"),_("code",[v._v("[^EF]")]),v._v("。")]),v._v(" "),_("p",[v._v("我们已经知道"),_("code",[v._v("[EF]")]),v._v("可以匹配那些匹配"),_("code",[v._v("E")]),_("strong",[v._v("或者")]),v._v("匹配"),_("code",[v._v("F")]),v._v("的内空，在前加上一个"),_("code",[v._v("^")]),v._v("表示取反。因为取了反，原来的逻辑或关系变成了逻辑与（具体请参见德摩根定律）。所以"),_("code",[v._v("[^EF]")]),v._v("匹配那些不能匹配"),_("code",[v._v("E")]),_("strong",[v._v("而且")]),v._v("不能匹配"),_("code",[v._v("F")]),v._v("的内容。")]),v._v(" "),_("p",[v._v("以上交并补规则单个看都不复杂，但它们可以任意组合，用起来就有点复杂。")]),v._v(" "),_("p",[v._v("比如"),_("code",[v._v("A|BC|[^D]E")]),v._v("表示匹配"),_("code",[v._v("A")]),v._v("或者同时匹配"),_("code",[v._v("B")]),v._v("和"),_("code",[v._v("C")]),v._v("或者不能匹配"),_("code",[v._v("D")]),v._v("但要匹配E的三种内容。这么长的规则只用"),_("code",[v._v("A|BC|[^D]E")]),v._v("就能准确表达，没有任何歧义，这就是正则的魅力。")]),v._v(" "),_("p",[v._v("这里有一个问题。"),_("code",[v._v("A|BC|[^D]E")]),v._v("表示"),_("code",[v._v("A")]),v._v("、"),_("code",[v._v("BC")]),v._v("和"),_("code",[v._v("[^D]E")]),v._v("的并集，还是表示"),_("code",[v._v("A|BC")]),v._v("跟"),_("code",[v._v("[^D]E")]),v._v("并集，还是表示"),_("code",[v._v("A")]),v._v("跟"),_("code",[v._v("BC|[^D]E")]),v._v("的并集呢？这就涉及到"),_("strong",[v._v("结合优先级")]),v._v("的问题了。")]),v._v(" "),_("p",[v._v("正确的答案是第一种，被|分割的部分是平级的。如果你想表示"),_("code",[v._v("A|BC")]),v._v("跟"),_("code",[v._v("[^D]E")]),v._v("的并集，那你需要写成"),_("code",[v._v("(A|BC)|[^D]E")]),v._v("。对了，"),_("strong",[v._v("遇事不决加括号")]),v._v("！")]),v._v(" "),_("p",[v._v("在前面的讨论中，"),_("code",[v._v("ABCDE")]),v._v("都是抽像的正则，我们并"),_("strong",[v._v("不关心具体的规则内容")]),v._v("。而对应的交、并补规则对所有正则都管用。现在我们开始讨论"),_("strong",[v._v("两大微观规则")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"第一条-单字符规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一条-单字符规则"}},[v._v("#")]),v._v(" 第一条，单字符规则")]),v._v(" "),_("p",[v._v("所谓单字符就是一次匹配一个字符，但字符的取值可能是五花八门。")]),v._v(" "),_("p",[v._v("一个字母"),_("code",[v._v("a")]),v._v(", 一个数字"),_("code",[v._v("1")]),v._v("都是正则，分别匹配包含"),_("code",[v._v("a")]),v._v("和包含"),_("code",[v._v("1")]),v._v("的内容。")]),v._v(" "),_("p",[v._v("如果我们想匹配数字"),_("code",[v._v("1234")]),v._v("，那么根据交集规则，我们写成"),_("code",[v._v("1234")]),v._v("就可以了。")]),v._v(" "),_("p",[v._v("如果我们想匹配所有可能出现的数字，则可以根据并集规则写成"),_("code",[v._v("0|1|2|3|4|5|6|7|8|9")]),v._v("。是不有点长。我们可以简化成"),_("code",[v._v("[0123456789]")]),v._v("。一下子少了很多坚线。")]),v._v(" "),_("p",[v._v("慢着，如果想匹配所有可能出现的小写字母呢？难不成要写成"),_("code",[v._v("[abc此处省略20个字母xyz]")]),v._v("？太长了😂")]),v._v(" "),_("p",[v._v("正则表达式为此提供了一种更加简化方法——连字符，可以使用减号-表示"),_("strong",[v._v("连续出现")]),v._v("的字符，只需写出头尾。所以我们可以把"),_("code",[v._v("[0123456789]")]),v._v("进一步简化成"),_("code",[v._v("[0-9]")]),v._v("，把"),_("code",[v._v("[abc...xyz]")]),v._v("简化成"),_("code",[v._v("[a-z]")]),v._v("。")]),v._v(" "),_("p",[v._v("如果要匹配所有字母，不区分大小写，可以写成"),_("code",[v._v("[a-zA-Z]")]),v._v("，如果还想顺手匹配所有数字，可以写成"),_("code",[v._v("[a-zA-Z0-9]")]),v._v("。")]),v._v(" "),_("p",[v._v("因为"),_("code",[v._v("[0-9]")]),v._v("很常用，大家又进一步简化成了"),_("code",[v._v("\\d")]),v._v("（对应单词 digit）。并非所有的正则引擎都支持这个"),_("code",[v._v("\\d")]),v._v("，有的默认不支持，需要开启 perl 兼容的正则引擎才行。")]),v._v(" "),_("p",[v._v("因为"),_("code",[v._v("[a-zA-Z]")]),v._v("也很常用，大家就把它简化成"),_("code",[v._v("\\a")]),v._v("（对应单词 alpha）。")]),v._v(" "),_("p",[v._v("同样的，如果想匹配大小写字母、数字和下划线（也就是所有单词字符），可以写成"),_("code",[v._v("[a-zA-Z0-9_]")]),v._v("。也是因为太常用，大家将其简化为"),_("code",[v._v("\\w")]),v._v("（对应单词 word）。")]),v._v(" "),_("p",[v._v("如果想匹配一些空白字符，可以写成"),_("code",[v._v("[ \\t\\r\\n\\v\\f]")]),v._v("，这个正则会匹配空格、水平制表符、回车、换行、 垂直制表符和 Page break 记。这里用到了跟 c 语言 printf 函数一样的转义字符。同样因为使用广泛，被简化为"),_("code",[v._v("\\s")]),v._v("（对应单词 space）。")]),v._v(" "),_("p",[v._v("我们说过，正则支持取反操作。"),_("code",[v._v("[0-9]")]),v._v("表示匹配所有数字，那"),_("code",[v._v("[^0-9]")]),v._v("就表示匹配所有非数字字符。因为使用广泛，人们将其简写成"),_("code",[v._v("\\D")]),v._v("。大家注意，"),_("code",[v._v("[0-9]")]),v._v("简写成"),_("code",[v._v("\\d")]),v._v("（小写字母），对应的"),_("code",[v._v("[^0-9]")]),v._v("简写成"),_("code",[v._v("\\D")]),v._v("（大写字母）。以此类推，"),_("code",[v._v("\\a")]),v._v("取反是"),_("code",[v._v("\\A")]),v._v("、"),_("code",[v._v("\\w")]),v._v("取反是"),_("code",[v._v("\\W")]),v._v("、"),_("code",[v._v("\\s")]),v._v("取反是"),_("code",[v._v("\\S")]),v._v("。一下子都记住了吧。")]),v._v(" "),_("p",[v._v("有了连字符和并集规则，"),_("strong",[v._v("理论上我们可以匹配所有字符")]),v._v("。但是 Unicode 有上百万字符，难道我们都要写到方括号里吗？不能够。")]),v._v(" "),_("p",[v._v("我们可以利用取反操作。只要"),_("strong",[v._v("排除少量不常用字符")]),v._v("，就可以匹配剩下的大多数字符了。但排除哪个呢？最终人们决定排除"),_("code",[v._v("\\n")]),v._v("。为什么呢？因为一般而言，正则都是"),_("strong",[v._v("逐行匹配")]),v._v("的，一次匹配一行内容，不会遇到换行符。最终可以用"),_("code",[v._v("[^\\n]")]),v._v("表示匹配所有字符。同样因为太常用，这一写法被简化成句点.。 也就是说在正则表达式中，一个.可以匹配"),_("code",[v._v("\\n")]),v._v("以外的所有字符。")]),v._v(" "),_("p",[v._v("最后需要额外说一下字符反斜杠\\。我们前面提到的"),_("code",[v._v("\\d")]),v._v("、"),_("code",[v._v("\\w")]),v._v("都使用反斜杠进行转义。如果要匹配"),_("code",[v._v("\\")]),v._v("就得写成"),_("code",[v._v("\\\\")]),v._v("。因为好多语言的字符串也是使用反斜杠进行转义（比如用\\n表示换行），所以你会在代码中看到像"),_("code",[v._v('"\\\\\\\\"')]),v._v("这样的写法。如果你是初学者，一定会这样的鬼画符吓到。其实很简单。 第一个反斜杠用于转义第二个反斜杠，表示"),_("strong",[v._v("一个")]),v._v("反斜杠字符；第三个转义第四个。第一个和第三个反斜杠是给"),_("strong",[v._v("语言编译器")]),v._v("用的。如果你用printf之类的函数将这段打印到标准输出，你会看到"),_("code",[v._v("\\\\")]),v._v("，又是两个反斜杠。 这次转义是给"),_("strong",[v._v("正则引擎")]),v._v("用的，用于表示匹配\\这个字符。")]),v._v(" "),_("p",[v._v("那么多斜杠确实容易出错。好多语言都提供所谓 "),_("strong",[v._v("raw 字符串")]),v._v("，这种字符串"),_("strong",[v._v("不支持转义功能")]),v._v("，也就不需要写额外的反斜杠。比如在 go 语言中"),_("code",[v._v('"\\\\\\\\"')]),v._v('可以写成 "'),_("code",[v._v("\\\\")]),v._v('"（注意两侧的``）是不是清爽多了🤪。')]),v._v(" "),_("p",[v._v("以上基本上就是单字符规则的所有内容。下面我们继续讨论")]),v._v(" "),_("h2",{attrs:{id:"第二条-多字符规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二条-多字符规则"}},[v._v("#")]),v._v(" 第二条，多字符规则")]),v._v(" "),_("p",[v._v("如果想匹配两位数字，可以利用交集规则，写成"),_("code",[v._v("\\d\\d")]),v._v("，此正则会先匹配一个数字再匹配一个数字，最终匹配的是两位数字。如果想匹配三位数字，需要写成"),_("code",[v._v("\\d\\d\\d")]),v._v("，四位数字写成"),_("code",[v._v("\\d\\d\\d\\d")]),v._v("。")]),v._v(" "),_("p",[v._v("那如果想匹配一位"),_("strong",[v._v("或者")]),v._v("两位数字"),_("strong",[v._v("或者")]),v._v("三位数字"),_("strong",[v._v("或者")]),v._v("四位数字（也就是四位以内的数字），需要写成")]),v._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("|")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("|")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("|")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("\\")]),v._v("d\n复制代码\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("有点长，但是 it works！如果想匹配所有的八位"),_("strong",[v._v("以内")]),v._v("的数字呢？那就得写很长很长了。为此，人们又想了个简化的办法。这次引入了大括号"),_("code",[v._v("{}")]),v._v("。")]),v._v(" "),_("p",[v._v("刚才的正则是可以简化成"),_("code",[v._v("\\d{1,4}")]),v._v("，展开就是"),_("code",[v._v("\\d|\\d\\d|\\d\\d\\d|\\d\\d\\d\\d")]),v._v("。大括号中第一个数字表示最短匹配的次数，第二个数字表示最长匹配的次数。")]),v._v(" "),_("p",[v._v("如果想匹配"),_("strong",[v._v("八位以内")]),v._v("的数字，就可以写成"),_("code",[v._v("\\d{1,8}")]),v._v("，是不是很简洁呢？")]),v._v(" "),_("p",[v._v("如果只想匹配"),_("strong",[v._v("一个八位数")]),v._v("，则可以写成"),_("code",[v._v("\\d{8,8}")]),v._v("。重复写两个8好像有点多余，还是简化成"),_("code",[v._v("\\d{8}")]),v._v("吧。")]),v._v(" "),_("p",[v._v("那能不能匹配任意长度的数字呢？ 理论上应该写成"),_("code",[v._v("\\d{1,∞}")]),v._v("，只是这个"),_("code",[v._v("∞")]),v._v("不好写，干脆省略，写成"),_("code",[v._v("\\d{1,}")]),v._v("算了。所以"),_("code",[v._v("\\d{1,}")]),v._v("表示可以匹配一位、两位、一直到任意长度的数字。也就是说"),_("code",[v._v("{1,}")]),v._v("表示前面的匹配内容"),_("strong",[v._v("至少出现一次")]),v._v("。因为这个至少出现一次也是特别常用，人们又进一步将其简化成"),_("code",[v._v("+")]),v._v("，最终我们的正则变成了"),_("code",[v._v("\\d+")]),v._v("，优雅的不行。")]),v._v(" "),_("p",[v._v("那能不能实现匹配"),_("strong",[v._v("出现零次")]),v._v("这种语义呢？ 可以，只要将大括号内第一个数字写成0就行。所以"),_("code",[v._v("a{0,}")]),v._v("可以匹配"),_("code",[v._v("a、aa……aaaa……")]),v._v("等各种情况。也就是说"),_("code",[v._v("{0,}")]),v._v("表示前面的匹配的内容出现"),_("strong",[v._v("多次或者不出现")]),v._v("。 同样十分常用，被人们简化成了"),_("code",[v._v("*")]),v._v("。所以原来的正则可以简化成"),_("code",[v._v("a*")]),v._v("。")]),v._v(" "),_("p",[v._v("最后就是"),_("code",[v._v("{0,1}")]),v._v("这种情况了，显然表示"),_("strong",[v._v("出现零次或者一次")]),v._v("。 不用说，懒人们将其简化成了"),_("code",[v._v("?")]),v._v("。所以"),_("code",[v._v("ab?")]),v._v("只能匹配"),_("code",[v._v("a")]),v._v("和"),_("code",[v._v("ab")]),v._v("两种情况。")]),v._v(" "),_("p",[v._v("看到这里，你基本已经理解了正则的常用功能。如果还不确定，就返回去再读几遍。最后我们引申出一些高级内容。")]),v._v(" "),_("h2",{attrs:{id:"高级内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高级内容"}},[v._v("#")]),v._v(" 高级内容")]),v._v(" "),_("h4",{attrs:{id:"_1-先说一下贪心。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-先说一下贪心。"}},[v._v("#")]),v._v(" 1. 先说一下"),_("strong",[v._v("贪心")]),v._v("。")]),v._v(" "),_("p",[v._v("给定一段 html "),_("code",[v._v("<h1>this is a title</h1><p>this is content</p>")]),v._v("。")]),v._v(" "),_("p",[v._v("如果我们想匹配h1标签的内容，我们可以写成"),_("code",[v._v("<h1>.*</h1>")]),v._v("。这里写了两遍"),_("code",[v._v("h1")]),v._v("。 显然，不想重复。我看到"),_("code",[v._v("/h1")]),v._v("后面有一个"),_("code",[v._v(">")]),v._v("，我能不能将正则改成"),_("code",[v._v("<h1>.*>")]),v._v("呢？")]),v._v(" "),_("p",[v._v("大家可以自己试一下。正则引擎会一直匹配到"),_("code",[v._v("</p>")]),v._v("里面的"),_("code",[v._v(">")]),v._v("。这是为什么呢？因为正则表达式"),_("strong",[v._v("默认使用贪心模式")]),v._v("，一次性匹配尽可能长的内容。所以在找到"),_("code",[v._v("/h1")]),v._v("后面的"),_("code",[v._v(">")]),v._v("之后还会继续向前找。")]),v._v(" "),_("p",[v._v("那有办法修正这种行为吗？有，使用"),_("code",[v._v("?")]),v._v("。你可以将正则改为"),_("code",[v._v("<h1>.*?>")]),v._v("，这样引擎就会在第一次遇到"),_("code",[v._v(">")]),v._v("的地方停下来。这里的"),_("code",[v._v("?")]),v._v("跟之前说的「出现零次或一次」可不是一个意思哈。跟在"),_("code",[v._v("*")]),v._v("后面表示非贪心模式。其实也是为了避免引入太多的特殊符号，所以复用了"),_("code",[v._v("?")]),v._v("，这一定程度上会给初学者带来困扰。没办法，大家只能克服了。")]),v._v(" "),_("h4",{attrs:{id:"_2-再说一下引用。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-再说一下引用。"}},[v._v("#")]),v._v(" 2. 再说一下"),_("strong",[v._v("引用")]),v._v("。")]),v._v(" "),_("p",[v._v("给定一段 html "),_("code",[v._v("<h1>this is a title</h1><h1>this is content</h2>")]),v._v("。这里第二个"),_("code",[v._v("<h1>")]),v._v("没有闭合，结束标签写成了"),_("code",[v._v("h2")]),v._v("。如果只想匹配正常结束的"),_("code",[v._v("h1")]),v._v("，那可以写成"),_("code",[v._v("<(h1)>.*</\\1>")]),v._v("。")]),v._v(" "),_("p",[v._v("这里有两点。第一，前面的"),_("code",[v._v("h1")]),v._v("两边加了括号。第二，在结尾的地方使用了"),_("code",[v._v("\\1")]),v._v("来"),_("strong",[v._v("引用")]),v._v("前面加括号的内容。 正则引擎会为每个括号分配一个编号（从1开始记数），并记录括号的内容，大家可以使用"),_("code",[v._v("\\+数字")]),v._v("的方式来引用。这样的正则等价于"),_("code",[v._v("<h1>.*</h1>")]),v._v("。")]),v._v(" "),_("p",[v._v("咋一看也没什么大不了的。但如果要匹配很多成对标签的话，引用的优势就体现出来了。例如"),_("code",[v._v("<(h1|p|artice|div)>.*?</\\1>")]),v._v("可以匹配"),_("code",[v._v("h1")]),v._v("、"),_("code",[v._v("p")]),v._v("、"),_("code",[v._v("article")]),v._v("和"),_("code",[v._v("div")]),v._v("四种闭合标签。"),_("strong",[v._v("Do not repeat yourself.")])]),v._v(" "),_("h4",{attrs:{id:"_3-最后说一下环视。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-最后说一下环视。"}},[v._v("#")]),v._v(" 3. 最后说一下"),_("strong",[v._v("环视")]),v._v("。")]),v._v(" "),_("p",[v._v("环视说起来有点抽像 。例子不太好举，这里我引用 "),_("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fa%2F2973495",target:"_blank",rel:"noopener noreferrer"}},[v._v("stack over flow"),_("OutboundLink")],1),v._v(" 的一篇回答内容。")]),v._v(" "),_("p",[v._v("比如我们有字符串"),_("code",[v._v("foobarbarfoo")]),v._v("。下面我将用大写字母表示想要匹配的内容。为了跟英语原文对应，我们规定当前字符"),_("strong",[v._v("右边为前")]),v._v("（未处理），"),_("strong",[v._v("左边为后")]),v._v("（已处理）。")]),v._v(" "),_("p",[v._v("如果只想匹配第一个出现的"),_("code",[v._v("bar")]),v._v("，也就是"),_("code",[v._v("fooBARbarfoo")]),v._v("。肯定不能只写成"),_("code",[v._v("bar")]),v._v("，因为第二个"),_("code",[v._v("bar")]),v._v("也会匹配到。我们希望正则引擎在每碰到一个"),_("code",[v._v("bar")]),v._v("的时候"),_("strong",[v._v("继续向前（右）看看")]),v._v("还有没有"),_("code",[v._v("bar")]),v._v("，如果"),_("strong",[v._v("还有")]),v._v("则说明不是第一个。所以，需要写成"),_("code",[v._v("bar(?=bar)")]),v._v("。 括号里以"),_("code",[v._v("?")]),v._v("开头，"),_("code",[v._v("=")]),v._v("表示检查是否"),_("strong",[v._v("出现")]),v._v("， 因为是继续"),_("strong",[v._v("向前（右）看")]),v._v("，所以叫做"),_("strong",[v._v("前向肯定环视")]),v._v("（Look ahead positive）。")]),v._v(" "),_("p",[v._v("如果想匹配第二个"),_("code",[v._v("bar")]),v._v("也就是"),_("code",[v._v("foobarBARfoo")]),v._v("，则需要写成"),_("code",[v._v("bar(?!bar)")]),v._v("。也就是说查到"),_("code",[v._v("bar")]),v._v("只后还要继续"),_("strong",[v._v("向前（右）看")]),v._v("，没有"),_("code",[v._v("bar")]),v._v("才算匹配到。因为是没有，所以叫"),_("strong",[v._v("前向否定环视")]),v._v("（Look ahead negative）。")]),v._v(" "),_("p",[v._v("我还可以通过"),_("strong",[v._v("向后（左）看")]),v._v("的办法来解决类似的问题。")]),v._v(" "),_("p",[v._v("如果想匹配第一个"),_("code",[v._v("bar")]),v._v(",也就是"),_("code",[v._v("fooBARbarfoo")]),v._v("，我们可以写成"),_("code",[v._v("(?<=foo)bar")]),v._v("，这是告诉正则引擎在找到"),_("code",[v._v("bar")]),v._v("之后还要回顾一下有没有遇到"),_("code",[v._v("foo")]),v._v("，只有碰到才算匹配成功。因为需向"),_("strong",[v._v("后（左）确定匹配成功，所以叫后向肯定环视")]),v._v("（Look behind positive）。")]),v._v(" "),_("p",[v._v("如果想匹配第二个"),_("code",[v._v("bar")]),v._v("，也就是"),_("code",[v._v("foobarBARfoo")]),v._v("，我们可以写成"),_("code",[v._v("(?<!foo)bar")]),v._v("，这是让引擎在找到"),_("code",[v._v("bar")]),v._v("之后回顾一下有没有遇到过"),_("code",[v._v("foo")]),v._v("，没有碰到才算匹配成功。因为需要向"),_("strong",[v._v("后（左）确定匹配不成功，所以叫后向否定环视")]),v._v("（Look behind negative）。")]),v._v(" "),_("p",[v._v("我们稍微回顾一下。所有的环视都需要用括号括起来，以?开始。匹配之后继续向"),_("strong",[v._v("前（右）检查叫前叫前向环视")]),v._v("，如果需要确保另一模式也匹配，叫"),_("strong",[v._v("肯定环视")]),v._v("，用=，否则是"),_("strong",[v._v("否定环视")]),v._v("，用!；匹配之后继续向"),_("strong",[v._v("后（左）检查叫后向环视")]),v._v("，为了跟前向有所区别，所以在?之后加了一个<，为大家指明方向，肯定和否标记则跟前向一样。")]),v._v(" "),_("p",[v._v("理解了环视，我们还可以做一些更有意思的事情。")]),v._v(" "),_("p",[_("strong",[v._v("第一个，可以匹配单词的边界")]),v._v("。一个单词两边都有空格。单词的左边界是一个虚拟的位置，它右边的字符肯定是匹配"),_("code",[v._v("\\w")]),v._v("，它左边的内容肯定匹配"),_("code",[v._v("\\W")]),v._v("。我们可以要求正则引擎"),_("strong",[v._v("同时向前看和向后看")]),v._v("。所以可以写成"),_("code",[v._v("(?<=\\W)(?=\\w)")]),v._v("。这里两个括号之间是空的，表示只匹配位置，不消耗内容。同样的，右边的边界也是个虚拟位置，它左边的字符肯定是匹配"),_("code",[v._v("\\w")]),v._v("，它右边的字符肯定匹配"),_("code",[v._v("\\W")]),v._v("的位置，所以可以写成"),_("code",[v._v("(?<=\\w)(?=\\W)")]),v._v("。把这两个正则使用并集规则合到一起就是"),_("code",[v._v("(?<=\\W)(?=\\w)|(?<=\\w)(?=\\W)")]),v._v("，就可以匹配单词的左右边界。同样因为常用，人们把它简化成了"),_("code",[v._v("\\b")]),v._v("。")]),v._v(" "),_("p",[v._v("也就是说"),_("code",[v._v("\\b")]),v._v("匹配单词边界。正则"),_("code",[v._v("\\bbar")]),v._v("只会匹配字符串"),_("code",[v._v("foo bar")]),v._v("中的"),_("code",[v._v("bar")]),v._v("，而不会匹配"),_("code",[v._v("foobar")]),v._v("中的"),_("code",[v._v("bar")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("第二个，可以匹配一行的开始和结束")]),v._v("。一行的开始，顾名思义，就是第一个字符之前的位置，在它之前没有字符，在它之后是任意字符，所以我们可以写成"),_("code",[v._v("(?<!.)(?=.)")]),v._v("。对于一行的结束，我们可以如法炮制，写成"),_("code",[v._v("(?<=.)(?!.)")]),v._v("。同样因为常用，此二者被分别简化成了"),_("code",[v._v("^")]),v._v("和"),_("code",[v._v("$")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[_("em",[v._v("因为一行的开始跟结束非常特殊，正则引擎可以直接标记，根本用不到环视这样的大招。 我将它们放到一起讲只是为了逻辑上的统一。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("差不多该搁笔了。所谓言有尽而意无穷。我们讲重构、讲抽象，说到底就是要站在更高的视角看问题，要有全局意识，要有大局观。学习正则就是一个很好的例子，如果不从整体上去认识它，就会陷入死记硬背各种模式境地，费时费力容易出错不说，最关键的是会消磨你的学习热情。所以，我们在埋头学习的时候一定要时常浮出水面透透气，多思考、多总结，这样才能事半功倍。与君共勉💯")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("--本文引用自--"),_("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Ftaoshu.in%2Fabout.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("涛叔"),_("OutboundLink")],1),v._v("的"),_("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Ftaoshu.in%2Fhello-regexp.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("正则表达式入门"),_("OutboundLink")],1)])])])])}),[],!1,null,null,null);_.default=t.exports}}]);